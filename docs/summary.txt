--Жизненный цикл React-компонента--

Инициализация:
constructor (props) {   
	super(props);

	this.state = {
		option: props.option //установка начального состояния через передачу свойств
	}
}

componentWillMount () {   //вызывается перед тем, как компонент будет смонтирован
						//используется для получения данных, нужных для работы,
						//запросов на сервер, и т.п.
}

render () { //создат React-компонент, который помещается в виртуальный, а потом и в реальный DOM
		//не должен содержать "тяжелого" и асинхронного кода. 
}

componentDidMount () { //вызывается сразу после размещения компонента в DOM
		//здесь уже можно работать с фактическим DOM: вешать слушатели, получать данные, 
		//реальные размеры и положение в браузере и т.п.
}

Обновление:
Причиной обновления компонента является изменение его состояния, либо
состояния любого из его родителей (вызов setState(state))

componentWillReceiveProps (nextProps) { //вызывается при изменении состояния любого родителя (только родителя)
	//здесь доступны как текущие props, так и обновлнные nextProps
	//используется для проверки, изменились ли props и нужно ли менять 
	//состояние данного компонента
}

shouldComponentUpdate (nextProps, nextState) { //вызывается перед componentWillUpdate, содержит
											   //новые props и state. Тут разработчик может решить, нужно ли
											   //перестраивать компонент, исходя из сравнения старых и новых props и state
 return true;	//если этот метод вернёт true (или не реализован) то компонент будет пересторен
 				//если метод вернёт false, то выполнение методов обновления для компонента будет прекращено
}

В React есть специальный класс PureComponent. От него наследуются вместо {Component}
В нём реализован метод shouldComponentUpdate, в котором сравниваются ВСЕ props и state
и при изменении любого из свойств компонент обновляется. 

componentWillUpdate (nextProps, nextState) { //вызывается после изменения компонента (либо компонента, либо родителя)
		//используется для получения данных, необходимых для нового состояния
		//здесь в аргументах приходят новые props и state, а в свойствах пока старые
}

render () {}

componentDidUpdate (prevProps, prevState) { //вызывается после внесения изменений в фактический DOM
		//используется так же, как и componentDidMount(), но после изменения компонента
		//здесь в аргументах приходят старые props и state, а новые уже применены
}

Удаление компонента:

componentDidUnmount () { //вызывается при удалении компонента
		//используется для освобождения ресурсов, отписки от событий, и т.п. 

}

Ошибка в методах жизненного цикла.

componentDidCatch (error, info) { //Метод срабатывает при возникновении ошибки в методах 
																	//жизненного цикла компонента, либо его детей
																	//error - стандартный JS объект брошенной ошибки
																	//info - React объект со стеком React компонентов.
}

static getDerivedStateFromError(error) {
      // Обновление состояния, чтобы при последующей отрисовке показать аварийный UI.
      return { hasError: true };
}

--Паттерны React--

1. Передача функций в качестве аргументов. Таким образом можно вынести функционал
компонента наверх, тем самым обеспечив бОльшую гибкость компонента.
Например, в зависимости от переданной функции, компонент списка может отрисовывать
разные списки, а функции, получающие данные, будут описаны у родителя.

1.1 Render-функция. В компонент а качестве аргумента передаётся функция, которая содержит 
JSX код отрисовки части, или всего компонента. Таким образом можно гибко переиспользовать
логику компонента но менять его отображение сверху. 

2. Передача компонентов. Компоненты React также можно передавать в качестве аргументов. Таким
образом можно создвавть служебный компоненты-контейнеры, отвечающие за взаимное расположение
и CSS разметку нескольких компонентов, которые они получают в качестве аргументов. По такому же принципу строятся Error Boundry.

3. Children. React.Children имеет ряд полезных функций. Например, map применяет коллбэк-функцию ко всем children элемента, независимо от того, что они из себя представляют. Таким образом можно управлять отображением элементов: изменять, заменять их, скрывать, выбирать варианты... Изменять созданный компонент нельзя, поэтому применяется метод React.cloneElement(elem, {props}); и во вновь созданную копию элемента добавляются свойства из props.

4. Компоненты высшего порядка (HOC). Это, по сути, реализация паттерна "декоратор". Функционал компонента делится на части (например, логика и отображение) исходя из возможности переиспользовать части (например, любой сетевой компонент запрашивает данные, и пока не получит, ставит лоадер, при получении рендерит их, при ошибке рендерит сообщение об ошибке). Далее такой полу-компонент оборачивается в функцию, которая его возвращает. Эта функция принимает в качестве аргумента компонент, который будет рендерить, другие функции и параметры (например, компонент для рендеринга, и функцию запроса данных). Внутри такого компонента доступны props, переданные по вызову переменной, которой присвоена функция, через замыкание. Таких обёрток может быть сколько угодно, каждая добавляет свой функционал и аспекты логики.

--Context--

const { Provider, Consumer } = React.createContext(); создаёт пару компонентов, которые используются для передачи значения дочерним компонентам, не "прошивая" props промежуточных компонентов.
<Provider value={value}></Provider> оборачивает компоненты, которым будет доступен value. В месте, где нужно получить value, строится такая конструкция:
<Consumer>
	(value) => {return(компонент, использующий value)}
</Consumer>
Вместо такой конструкции удобно использовать HOC, оборачивающий компонент.


--Router--
import { BrowserRouter as Router, Route, Link} from 'react-router-dom';
<Router></Router> оборачивает приложение.
<Route path='/path' 
			 exact 
			 component={Component}
			 render={() => {JSX}}
			 />  
path - указывает url-подобный "адрес". Если текущий адрес на странице СОДЕРЖИТ path, то будет отрисован component либо render, соответствующий данному Route. Каждый Route проверяет, должен ли он быть отрисован в данный момент, и отрисовывается даже если его path является частью текущего адреса. Чтобы данный Route отрисовывался только при точном совпадении пути добавляется атрибут exact.

В path  можно описывать параметры path="/some/:param"
В render-функцию передаются три аргумента: match, location, history. В match.params будет находиться свойство param со значением, соответствующим реальному текущему адресу. Для этого удобно использовать HOC. В 'react-router-dom' есть функция withRouter, которая передаёт в соmponent параметры match, location, history.

history - работает с историей браузера. Содержит стек посещённых страниц, метод history.push() добавляет новый path  в стек и инициирует переход по этому адресу.
Относительные пути. Для того, чтобы получить относительный путь нужно закрывать базовый URL.
Например /link + 5 = /5 а /link/ + 5 = /link/5.
Опциональные параметры обозначаются /link/:id? такой роут будет срабатывать и на /link и на /link/5

import { Redirect } from 'react-router-dom'; служит для перенаправления пользоватля по определённому Route.
Если отрендерить <Redirect to='/route'> пользователь перейдёт по /route. Удобно использовать с флагами и
проверками, направляя пользователя в зависимости от условий (страница авторизации(небезопастная), ошибок)

import { Switch } from 'react-router-dom'; служит для создания блока Route, в котором сработает только первый подходящий.
Для этого блок из нескольких Route оборачивается в <Switch></Switch>. В конце такого блока можно поставить catcher для
несуществующих адресов. Если интерпертатор дошел до конца блока, значит ни один из Route не сработал. В конце можно
поставить либо <Redirect to="/404-page"(или "/")> либо Route Без to (будет срабатывать при любом адресе)

--Redux--

import { Provider } from 'react-redux';
import {connect} from 'react-redux';

<Provider></Provider> оборачивает приложение аналогично Context.Provider

export default connect(mapStateToProps, mapActionsToProps)(Component); это всторенный
компонент высшего порядка, реализующий Consumer для Redux.
Component получит в props значения из store, преобразованные с помощью mapStateToProps.
Component получит в props значения actionCreators, связанные с dispatch, преобразованные
с помощью функции mapActionsToProps.
Если вместо функции mapActionsToProps передать вторым аргументом в connect
объект actions с actionCreators, то connect автоматически применит BindActionCreators и
вернёт все actionCreators связанные c dispatch в props.

import { bindActionCreators } from 'redux'; функция, которая связыват actionCreators с
dispatch и возвращает объект с ключами, соответствующими именам actionCreators, но уже
связанными с dispatch.




